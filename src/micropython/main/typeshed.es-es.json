{
  "files": {
    "/typeshed/stdlib/VERSIONS": "# The structure of this file is as follows:\n# - Blank lines and comments starting with `#` are ignored.\n# - Lines contain the name of a module, followed by a colon,\n#   a space, and a version range (for example: `symbol: 2.7-3.9`).\n#\n# Version ranges may be of the form \"X.Y-A.B\" or \"X.Y-\". The\n# first form means that a module was introduced in version X.Y and last\n# available in version A.B. The second form means that the module was\n# introduced in version X.Y and is still available in the latest\n# version of Python.\n#\n# If a submodule is not listed separately, it has the same lifetime as\n# its parent module.\n#\n# Python versions before 2.7 are ignored, so any module that was already\n# present in 2.7 will have \"2.7\" as its minimum version. Version ranges\n# for unsupported versions of Python 3 (currently 3.5 and lower) are\n# generally accurate but we do not guarantee their correctness.\n\nantigravity: 3.0-\narray: 3.0-\naudio: 3.0-\nbuiltins: 3.0-\nerrno: 3.0-\ngc: 3.0-\nlove: 3.0-\nmachine: 3.0-\nmath: 3.0-\nmicrobit: 3.0-\nmicropython: 3.0-\nmusic: 3.0-\nneopixel: 3.0-\nos: 3.0-\nradio: 3.0-\nrandom: 3.0-\nspeech: 3.0-\nstruct: 3.0-\nsys: 3.0-\nthis: 3.0-\ntime: 3.0-\ntyping_extensions: 3.0-\ntyping: 3.0-\nuarray: 3.0-\nucollections: 3.0-\nuerrno: 3.0-\nuos: 3.0-\nurandom: 3.0-\nustruct: 3.0-\nusys: 3.0-\nutime: 3.0-",
    "/typeshed/stdlib/abc.pyi": "",
    "/typeshed/stdlib/array.pyi": "",
    "/typeshed/stdlib/audio.pyi": "\"\"\"Play sounds using the micro:bit (import ``audio`` for V1 compatibility).\n\"\"\"\n\n# Re-export for V1 compatibility.\nfrom .microbit.audio import (\n    is_playing as is_playing,\n    play as play,\n    stop as stop,\n    AudioFrame as AudioFrame,\n    SoundEffect as SoundEffect,\n)\n",
    "/typeshed/stdlib/builtins.pyi": "",
    "/typeshed/stdlib/errno.pyi": "",
    "/typeshed/stdlib/gc.pyi": "",
    "/typeshed/stdlib/log.pyi": "",
    "/typeshed/stdlib/love.pyi": "",
    "/typeshed/stdlib/machine.pyi": "\"\"\"Utilidades de bajo nivel. (m\u00e1quina)\"\"\"\nfrom typing import Any\nfrom .calliope import MicroBitDigitalPin\n\ndef unique_id() -> bytes:\n    \"\"\"Obtiene una cadena de bytes con un identificador \u00fanico de una placa. (id \u00fanico)\n\nExample: ``machine.unique_id()``\n\n:return: An identifier that varies from one board instance to another.\"\"\"\n    ...\n\ndef reset() -> None:\n    \"\"\"Restablece el dispositivo de una forma similar a pulsar el bot\u00f3n externo RESET. (restablecer)\n\nExample: ``machine.reset()``\"\"\"\n    ...\n\ndef freq() -> int:\n    \"\"\"Obtiene la frecuencia de la CPU en hercios. (frec)\n\nExample: ``machine.freq()``\n\n:return: The CPU frequency.\"\"\"\n    ...\n\ndef disable_irq() -> Any:\n    \"\"\"Desactiva las solicitudes de interrupci\u00f3n. (desactivar irq)\n\nExample: ``interrupt_state = machine.disable_irq()``\n\n:return: the previous IRQ state which should be considered an opaque value\n\nThe return value should be passed to the ``enable_irq`` function to restore\ninterrupts to their original state.\"\"\"\n    ...\n\ndef enable_irq(state: Any) -> None:\n    \"\"\"Reactiva las solicitudes de interrupci\u00f3n. (activar irq)\n\nExample: ``machine.enable_irq(interrupt_state)``\n\n:param state: (estado) Valor devuelto por la llamada m\u00e1s reciente a la funci\u00f3n ``disable_irq``.\"\"\"\n    ...\n\ndef time_pulse_us(pin: MicroBitDigitalPin, pulse_level: int, timeout_us: int=1000000) -> int:\n    \"\"\"Cronometra el estado de un pin. (cronometrar estado us)\n\nExample: ``time_pulse_us(pin0, 1)``\n\nIf the current input value of the pin is different to ``pulse_level``, the\nfunction first waits until the pin input becomes equal to\n``pulse_level``, then times the duration that the pin is equal to\n``pulse_level``. If the pin is already equal to ``pulse_level`` then timing\nstarts straight away.\n\n:param pin: Pin a usar\n:param pulse_level: (nivel de estado) 0 para cronometrar un estado bajo o 1 para un estado alto\n:param timeout_us: (tiempo de espera us) Tiempo de espera en microsegundos\n:return: The duration of the pulse in microseconds, or -1 for a timeout waiting for the level to match ``pulse_level``, or -2 on timeout waiting for the pulse to end\"\"\"\n    ...\n\nclass mem:\n    \"\"\"Clase para las vistas de memoria ``mem8``, ``mem16`` y ``mem32``.\"\"\"\n\n    def __getitem__(self, address: int) -> int:\n        \"\"\"Accede a un valor de la memoria. (obtener elemento)\n\n:param address: (direcci\u00f3n) La direcci\u00f3n de memoria.\n:return: The value at that address as an integer.\"\"\"\n        ...\n\n    def __setitem__(self, address: int, value: int) -> None:\n        \"\"\"Establece un valor en la direcci\u00f3n dada. (configurar elemento)\n\n:param address: (direcci\u00f3n) La direcci\u00f3n de memoria.\n:param value: (valor) El valor entero a establecer.\"\"\"\n        ...\nmem8: mem\n\"\"\"Vista de memoria de 8 bits (byte).\"\"\"\nmem16: mem\n\"\"\"Vista de memoria de 16 bits.\"\"\"\nmem32: mem\n\"\"\"Vista de memoria de 32 bits.\"\"\"",
    "/typeshed/stdlib/math.pyi": "",
    "/typeshed/stdlib/micropython.pyi": "",
    "/typeshed/stdlib/music.pyi": "\"\"\"Crear y reproducir melod\u00edas. (m\u00fasica)\"\"\"\nfrom typing import Optional, Tuple, Union, List\nfrom .calliope import MicroBitDigitalPin, pin0\nDADADADUM: Tuple[str, ...]\n\"\"\"Melod\u00eda: apertura de la \"Sinfon\u00eda n.\u00ba 5 en do menor\" de Beethoven.\"\"\"\nENTERTAINER: Tuple[str, ...]\n\"\"\"Melod\u00eda: fragmento inicial del cl\u00e1sico Ragtime de Scott Joplin \u201cThe Entertainer\u201d.\"\"\"\nPRELUDE: Tuple[str, ...]\n\"\"\"Melod\u00eda: apertura del primer \"Preludio en do mayor\" de los 48 Preludios y Fugas de J. S. Bach. (preludio)\"\"\"\nODE: Tuple[str, ...]\n\"\"\"Melod\u00eda: tema \u201cOda a la alegr\u00eda\u201d de la \"Sinfon\u00eda n.\u00ba 9 en re menor\" de Beethoven. (oda)\"\"\"\nNYAN: Tuple[str, ...]\n\"\"\"Melod\u00eda: el tema de Nyan Cat (http://www.nyan.cat/).\n\nThe composer is unknown. This is fair use for educational porpoises (as they say in New York).\"\"\"\nRINGTONE: Tuple[str, ...]\n\"\"\"Melod\u00eda: algo que suena como un tono de llamada de un tel\u00e9fono m\u00f3vil. (tono de llamada)\n\nTo be used to indicate an incoming message.\n\"\"\"\nFUNK: Tuple[str, ...]\n\"\"\"Melod\u00eda: una l\u00ednea de bajo funky para agentes secretos y maestros criminales.\"\"\"\nBLUES: Tuple[str, ...]\n\"\"\"Melod\u00eda: \"walking bass\" con un blues boogie-woogie de 12 compases.\"\"\"\nBIRTHDAY: Tuple[str, ...]\n\"\"\"Melod\u00eda: \u201cCumplea\u00f1os feliz\u201d (cumplea\u00f1os)\n\nFor copyright status see: http://www.bbc.co.uk/news/world-us-canada-34332853\n\"\"\"\nWEDDING: Tuple[str, ...]\n\"\"\"Melod\u00eda: coro nupcial de la \u00f3pera de Wagner \"Lohengrin\". (boda)\"\"\"\nFUNERAL: Tuple[str, ...]\n\"\"\"Melod\u00eda: \u201cMarcha f\u00fanebre\u201d, conocida tambi\u00e9n como \"Sonata para piano n.\u00ba 2 en si bemol menor, Op. 35\" de Fr\u00e9d\u00e9ric Chopin.\"\"\"\nPUNCHLINE: Tuple[str, ...]\n\"\"\"Melod\u00eda: un fragmento divertido que representa que se ha hecho un chiste. (remate)\"\"\"\nPYTHON: Tuple[str, ...]\n\"\"\"Melod\u00eda: la marcha de John Philip Sousa \u201cLiberty Bell\u201d, tambi\u00e9n conocida por ser el tema del \u201cMonty Python Flying Circus\u201d (de donde obtiene su nombre el lenguaje de programaci\u00f3n Python).\"\"\"\nBADDY: Tuple[str, ...]\n\"\"\"Melod\u00eda: entrada de un malote en la \u00e9poca del cine mudo. (malote)\"\"\"\nCHASE: Tuple[str, ...]\n\"\"\"Melod\u00eda: escena de persecuci\u00f3n en la \u00e9poca del cine mudo. (persecuci\u00f3n)\"\"\"\nBA_DING: Tuple[str, ...]\n\"\"\"Melod\u00eda: una se\u00f1al corta para indicar que algo ha pasado.\"\"\"\nWAWAWAWAA: Tuple[str, ...]\n\"\"\"Melod\u00eda: un tromb\u00f3n muy triste.\"\"\"\nJUMP_UP: Tuple[str, ...]\n\"\"\"Melod\u00eda: para usar en un juego, indicando un movimiento ascendente. (saltar arriba)\"\"\"\nJUMP_DOWN: Tuple[str, ...]\n\"\"\"Melod\u00eda: para usar en un juego, indicando un movimiento descendente. (saltar abajo)\"\"\"\nPOWER_UP: Tuple[str, ...]\n\"\"\"Melod\u00eda: una fanfarria para indicar un logro desbloqueado. (subida de potencia)\"\"\"\nPOWER_DOWN: Tuple[str, ...]\n\"\"\"Melod\u00eda: una fanfarria triste para indicar un logro perdido. (bajada de potencia)\"\"\"\n\ndef set_tempo(ticks: int=4, bpm: int=120) -> None:\n    \"\"\"Establece el ritmo aproximado de la reproducci\u00f3n. (configurar tempo)\n\nExample: ``music.set_tempo(bpm=120)``\n\n:param ticks: (tics) El n\u00famero de tics que constituyen un ritmo.\n:param bpm: Un entero que determina el n\u00famero de compases por minuto.\n\nSuggested default values allow the following useful behaviour:\n\n- music.set_tempo() \u2013 reset the tempo to default of ticks = 4, bpm = 120\n- music.set_tempo(ticks=8) \u2013 change the \u201cdefinition\u201d of a beat\n- music.set_tempo(bpm=180) \u2013 just change the tempo\n\nTo work out the length of a tick in milliseconds is very simple arithmetic:\n60000/bpm/ticks_per_beat. For the default values that\u2019s\n60000/120/4 = 125 milliseconds or 1 beat = 500 milliseconds.\"\"\"\n    ...\n\ndef get_tempo() -> Tuple[int, int]:\n    \"\"\"Obtiene el ritmo actual como una tupla de enteros: ``(ticks, bpm)``. (obtener tempo)\n\nExample: ``ticks, beats = music.get_tempo()``\n\n:return: The temp as a tuple with two integer values, the ticks then the beats per minute.\"\"\"\n    ...\n\ndef play(music: Union[str, List[str], Tuple[str, ...]], pin: Optional[MicroBitDigitalPin]=pin0, wait: bool=True, loop: bool=False) -> None:\n    \"\"\"Reproduce m\u00fasica. (reproducir)\n\nExample: ``music.play(music.NYAN)``\n\n:param music: (m\u00fasica) m\u00fasica especificada en `una notaci\u00f3n especial <https://microbit-micropython.readthedocs.io/en/v2-docs/music.html#musical-notation>`_\n:param pin: pin de salida para usar con un altavoz externo (por defecto ``pin0``), ``None`` para que no haya sonido.\n:param wait: (esperar) Si ``wait`` se configura como ``True`` (verdadero), esta funci\u00f3n estar\u00e1 bloqueando.\n:param loop: (bucle) Si ``loop`` se configura como ``True`` (verdadero), la melod\u00eda se repite hasta que se llama a ``stop`` o se interrumpe la llamada de bloqueo.\n\nMany built-in melodies are defined in this module.\"\"\"\n    ...\n\ndef pitch(frequency: int, duration: int=-1, pin: Optional[MicroBitDigitalPin]=pin0, wait: bool=True) -> None:\n    \"\"\"Reproduce una nota. (tono)\n\nExample: ``music.pitch(185, 1000)``\n\n:param frequency: (frecuencia) Una frecuencia entera\n:param duration: (duraci\u00f3n) La duraci\u00f3n en milisegundos. Si es negativa, el sonido continuar\u00e1 hasta la siguiente llamada o una llamada a ``stop``.\n:param pin: Pin de salida opcional (por defecto, ``pin0``).\n:param wait: (esperar) Si ``wait`` se configura como ``True`` (verdadero), esta funci\u00f3n estar\u00e1 bloqueando.\n\nFor example, if the frequency is set to 440 and the length to\n1000 then we hear a standard concert A for one second.\n\nYou can only play one pitch on one pin at any one time.\"\"\"\n    ...\n\ndef stop(pin: Optional[MicroBitDigitalPin]=pin0) -> None:\n    \"\"\"Detiene la reproducci\u00f3n de toda la m\u00fasica en el altavoz integrado y en cualquier pin que est\u00e9 emitiendo sonido. (detener)\n\nExample: ``music.stop()``\n\n:param pin: Se puede proporcionar un argumento opcional para especificar un pin; por ejemplo, ``music.stop(pin1)``.\"\"\"\n\ndef reset() -> None:\n    \"\"\"Restablece los valores de \"ticks\", \"bpm\", \"duration\" y \"octave\" a sus valores por defecto. (restablecer)\n\nExample: ``music.reset()``\n\nValues:\n- ``ticks = 4``\n- ``bpm = 120``\n- ``duration = 4``\n- ``octave = 4``\"\"\"\n    ...",
    "/typeshed/stdlib/neopixel.pyi": "\"\"\"Tiras de LED RGB y RGBW accesibles individualmente.\"\"\"\nfrom .calliope import MicroBitDigitalPin\nfrom typing import Tuple\n\nclass NeoPixel:\n\n    def __init__(self, pin: MicroBitDigitalPin, n: int, bpp: int=3) -> None:\n        \"\"\"Inicializa una nueva tira de LED NeoPixel controlada a trav\u00e9s de un pin.\n\nExample: ``np = neopixel.NeoPixel(pin0, 8)``\n\nTo support RGBW neopixels, a third argument can be passed to\n``NeoPixel`` to indicate the number of bytes per pixel (``bpp``).\nFor RGBW, this is is 4 rather than the default of 3 for RGB and GRB.\n\nEach pixel is addressed by a position (starting from 0). Neopixels are\ngiven RGB (red, green, blue) / RGBW (red, green, blue, white) values\nbetween 0-255 as a tuple. For example, in RGB, ``(255,255,255)`` is\nwhite. In RGBW, ``(255,255,255,0)`` or ``(0,0,0,255)`` is white.\n\nSee `the online docs <https://microbit-micropython.readthedocs.io/en/v2-docs/neopixel.html>`_ for warnings and other advice.\n\n:param pin: El pin que controla la tira NeoPixel.\n:param n: El n\u00famero de LED NeoPixel de la tira.\n:param bpp: Bytes por p\u00edxel. Para compatibilidad con NeoPixel RGBW de micro:bit V2, pasa 4 en lugar del valor predeterminado 3 para RGB y GRB.\"\"\"\n        ...\n\n    def clear(self) -> None:\n        \"\"\"Borrar todos los p\u00edxeles. (borrar)\n\nExample: ``np.clear()``\"\"\"\n        ...\n\n    def show(self) -> None:\n        \"\"\"Muestra los p\u00edxeles. (mostrar)\n\nExample: ``np.show()``\n\nMust be called for any updates to become visible.\"\"\"\n        ...\n\n    def write(self) -> None:\n        \"\"\"Muestra los p\u00edxeles (solo micro:bit V2). (escribir)\n\nExample: ``np.write()``\n\nMust be called for any updates to become visible.\n\nEquivalent to ``show``.\"\"\"\n        ...\n\n    def fill(self, colour: Tuple[int, ...]) -> None:\n        \"\"\"Colorea todos los p\u00edxeles con un valor RGB/RGBW dado. (llenar)\n\nExample: ``np.fill((0, 0, 255))``\n\n:param colour: (color) Una tupla de la misma longitud que el n\u00famero de bytes por p\u00edxel (bpp).\n\nUse in conjunction with ``show()`` to update the neopixels.\"\"\"\n        ...\n\n    def __setitem__(self, key: int, value: Tuple[int, ...]) -> None:\n        \"\"\"Establece el color de un p\u00edxel. (configurar elemento)\n\nExample: ``np[0] = (255, 0, 0)``\n\n:param key: (clave) El n\u00famero de p\u00edxel.\n:param value: (valor) El color.\"\"\"\n\n    def __getitem__(self, key: int) -> Tuple[int, ...]:\n        \"\"\"Obtiene el color de un p\u00edxel. (obtener elemento)\n\nExample: ``r, g, b = np[0]``\n\n:param key: (clave) El n\u00famero de p\u00edxel.\n:return: The colour tuple.\"\"\"\n\n    def __len__(self) -> int:\n        \"\"\"Obtiene la longitud de esta tira de p\u00edxeles. (lon)\n\nExample: ``len(np)``\"\"\"",
    "/typeshed/stdlib/os.pyi": "",
    "/typeshed/stdlib/power.pyi": "\"\"\"Manage the power modes of the micro:bit (V2 only).\n\"\"\"\n\nfrom microbit import MicroBitDigitalPin, Button\nfrom typing import Optional, Tuple, Union\n\ndef off() -> None:\n    \"\"\"Power down the board to the lowest possible power mode.\n\n    Example: ``power.off()``\n\n    This is the equivalent to pressing the reset button for a few seconds,\n    to set the board in \"Off mode\".\n\n    The micro:bit will only wake up if the reset button is pressed or,\n    if on battery power, when a USB cable is connected.\n\n    When the board wakes up it will start for a reset state, so your program\n    will start running from the beginning.\n    \"\"\"\n    ...\n\ndef deep_sleep(\n    ms: Optional[int] = None,\n    wake_on: Optional[\n        Union[MicroBitDigitalPin, Button] | Tuple[MicroBitDigitalPin | Button, ...]\n    ] = None,\n    run_every: bool = True,\n) -> None:\n    \"\"\"Set the micro:bit into a low power mode where it can wake up and continue operation.\n\n    Example: ``power.deep_sleep(wake_on=(button_a, button_b))``\n\n    The program state is preserved and when it wakes up it will resume\n    operation where it left off.\n\n    Deep Sleep mode will consume more battery power than Off mode.\n\n    The wake up sources are configured via arguments.\n\n    The board will always wake up when receiving UART data, when the reset\n    button is pressed (which resets the board) or, in battery power,\n    when the USB cable is inserted.\n\n    When the ``run_every`` parameter is set to ``True`` (the default), any\n    function scheduled with ``run_every`` will momentarily wake up the board\n    to run and when it finishes it will go back to sleep.\n\n    :param ms: A time in milliseconds to wait before it wakes up.\n    :param wake_on: A single instance or a tuple of pins and/or buttons to wake up the board, e.g. ``deep_sleep(wake_on=button_a)`` or ``deep_sleep(wake_on=(pin0, pin2, button_b))``.\n    :param run_every: A boolean to configure if the functions scheduled with ``microbit.run_every`` will continue to run while it sleeps.\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/radio.pyi": "",
    "/typeshed/stdlib/random.pyi": "",
    "/typeshed/stdlib/speech.pyi": "\"\"\"Hacer que el micro:bit hable, cante y haga otros sonidos parecidos a la voz. (habla)\"\"\"\nfrom typing import Optional\nfrom .calliope import MicroBitDigitalPin, pin0\n\ndef translate(words: str) -> str:\n    \"\"\"Traducir palabras en ingl\u00e9s a fonemas. (traducir)\n\nExample: ``speech.translate('hello world')``\n\n:param words: (palabras) Una cadena de palabras en ingl\u00e9s.\n:return: A string containing a best guess at the appropriate phonemes to pronounce.\nThe output is generated from this `text to phoneme translation table <https://github.com/s-macke/SAM/wiki/Text-to-phoneme-translation-table>`_.\n\nThis function should be used to generate a first approximation of phonemes\nthat can be further hand-edited to improve accuracy, inflection and\nemphasis.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef pronounce(phonemes: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: Optional[MicroBitDigitalPin]=pin0) -> None:\n    \"\"\"Pronunciar fonemas. (pronunciar)\n\nExample: ``speech.pronounce(' /HEHLOW WERLD')``\n\n:param phonemes: (fonemas) La cadena de fonemas a pronunciar\n:param pitch: (tono) Un n\u00famero que representa el tono de la voz\n:param speed: (velocidad) Un n\u00famero que representa la velocidad de la voz\n:param mouth: (boca) Un n\u00famero que representa la boca de la voz\n:param throat: (garganta) Un n\u00famero que representa la garganta de la voz\n:param pin: Se puede usar un argumento opcional para especificar el pin de salida, reemplazando el valor predeterminado de ``pin0``.\nSi no queremos que se reproduzca ning\u00fan sonido, podemos usar ``pin=None``. Solo para el micro:bit V2.\n\nOverride the optional pitch, speed, mouth and throat settings to change the\ntimbre (quality) of the voice.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef say(words: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: MicroBitDigitalPin=pin0) -> None:\n    \"\"\"Dice palabras en ingl\u00e9s. (decir)\n\nExample: ``speech.say('hello world')``\n\n:param words: (palabras) La cadena de palabras a decir.\n:param pitch: (tono) Un n\u00famero que representa el tono de la voz\n:param speed: (velocidad) Un n\u00famero que representa la velocidad de la voz\n:param mouth: (boca) Un n\u00famero que representa la boca de la voz\n:param throat: (garganta) Un n\u00famero que representa la garganta de la voz\n:param pin: Se puede usar un argumento opcional para especificar el pin de salida, reemplazando el valor predeterminado de ``pin0``.\nSi no queremos que se reproduzca ning\u00fan sonido, podemos usar ``pin=None``. Solo para el micro:bit V2.\n\nThe result is semi-accurate for English. Override the optional pitch, speed,\nmouth and throat settings to change the timbre (quality) of the voice.\n\nThis is a short-hand equivalent of:\n``speech.pronounce(speech.translate(words))``\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef sing(phonemes: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: MicroBitDigitalPin=pin0) -> None:\n    \"\"\"Canta fonemas. (cantar)\n\nExample: ``speech.sing(' /HEHLOW WERLD')``\n\n:param phonemes: (fonemas) La cadena de palabras a cantar.\n:param pitch: (tono) Un n\u00famero que representa el tono de la voz\n:param speed: (velocidad) Un n\u00famero que representa la velocidad de la voz\n:param mouth: (boca) Un n\u00famero que representa la boca de la voz\n:param throat: (garganta) Un n\u00famero que representa la garganta de la voz\n:param pin: Se puede usar un argumento opcional para especificar el pin de salida, reemplazando el valor predeterminado de ``pin0``.\nSi no queremos que se reproduzca ning\u00fan sonido, podemos usar ``pin=None``. Solo para el micro:bit V2.\n\nOverride the optional pitch, speed, mouth and throat settings to change\nthe timbre (quality) of the voice.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...",
    "/typeshed/stdlib/struct.pyi": "",
    "/typeshed/stdlib/sys.pyi": "",
    "/typeshed/stdlib/this.pyi": "",
    "/typeshed/stdlib/time.pyi": "",
    "/typeshed/stdlib/types.pyi": "",
    "/typeshed/stdlib/typing.pyi": "",
    "/typeshed/stdlib/typing_extensions.pyi": "",
    "/typeshed/stdlib/uarray.pyi": "",
    "/typeshed/stdlib/ucollections.pyi": "",
    "/typeshed/stdlib/uerrno.pyi": "",
    "/typeshed/stdlib/urandom.pyi": "",
    "/typeshed/stdlib/ustruct.pyi": "",
    "/typeshed/stdlib/usys.pyi": "",
    "/typeshed/stdlib/utime.pyi": "",
    "/typeshed/stdlib/calliopemini/__init__.pyi": "",
    "/typeshed/stdlib/calliopemini/accelerometer.pyi": "",
    "/typeshed/stdlib/calliopemini/audio.pyi": "",
    "/typeshed/stdlib/calliopemini/compass.pyi": "",
    "/typeshed/stdlib/calliopemini/display.pyi": "",
    "/typeshed/stdlib/calliopemini/i2c.pyi": "",
    "/typeshed/stdlib/calliopemini/microphone.pyi": "",
    "/typeshed/stdlib/calliopemini/speaker.pyi": "",
    "/typeshed/stdlib/calliopemini/spi.pyi": "",
    "/typeshed/stdlib/calliopemini/uart.pyi": "",
    "/typeshed/stdlib/_typeshed/__init__.pyi": "",
    "/typeshed/stdlib/collections/__init__.pyi": "",
    "/src/pyrightconfig.json": "{ \n  \"pythonVersion\": \"3.6\",\n  \"pythonPlatform\": \"Linux\",\n  \"typeCheckingMode\": \"basic\",\n  \"typeshedPath\": \"/typeshed/\",\n  \"reportMissingModuleSource\": false,\n  \"reportWildcardImportFromLibrary\": false,\n  \"verboseOutput\": true\n }\n"
  }
}