{
  "files": {
    "/typeshed/stdlib/VERSIONS": "# The structure of this file is as follows:\n# - Blank lines and comments starting with `#` are ignored.\n# - Lines contain the name of a module, followed by a colon,\n#   a space, and a version range (for example: `symbol: 2.7-3.9`).\n#\n# Version ranges may be of the form \"X.Y-A.B\" or \"X.Y-\". The\n# first form means that a module was introduced in version X.Y and last\n# available in version A.B. The second form means that the module was\n# introduced in version X.Y and is still available in the latest\n# version of Python.\n#\n# If a submodule is not listed separately, it has the same lifetime as\n# its parent module.\n#\n# Python versions before 2.7 are ignored, so any module that was already\n# present in 2.7 will have \"2.7\" as its minimum version. Version ranges\n# for unsupported versions of Python 3 (currently 3.5 and lower) are\n# generally accurate but we do not guarantee their correctness.\n\nantigravity: 3.0-\narray: 3.0-\naudio: 3.0-\nbuiltins: 3.0-\nerrno: 3.0-\ngc: 3.0-\nlove: 3.0-\nmachine: 3.0-\nmath: 3.0-\nmicrobit: 3.0-\nmicropython: 3.0-\nmusic: 3.0-\nneopixel: 3.0-\nos: 3.0-\nradio: 3.0-\nrandom: 3.0-\nspeech: 3.0-\nstruct: 3.0-\nsys: 3.0-\nthis: 3.0-\ntime: 3.0-\ntyping_extensions: 3.0-\ntyping: 3.0-\nuarray: 3.0-\nucollections: 3.0-\nuerrno: 3.0-\nuos: 3.0-\nurandom: 3.0-\nustruct: 3.0-\nusys: 3.0-\nutime: 3.0-",
    "/typeshed/stdlib/abc.pyi": "",
    "/typeshed/stdlib/array.pyi": "",
    "/typeshed/stdlib/audio.pyi": "\"\"\"Play sounds using the micro:bit (import ``audio`` for V1 compatibility).\n\"\"\"\n\n# Re-export for V1 compatibility.\nfrom .microbit.audio import (\n    is_playing as is_playing,\n    play as play,\n    stop as stop,\n    AudioFrame as AudioFrame,\n    SoundEffect as SoundEffect,\n)\n",
    "/typeshed/stdlib/builtins.pyi": "",
    "/typeshed/stdlib/errno.pyi": "",
    "/typeshed/stdlib/gc.pyi": "",
    "/typeshed/stdlib/log.pyi": "",
    "/typeshed/stdlib/love.pyi": "",
    "/typeshed/stdlib/machine.pyi": "\"\"\"Utilitats de baix nivell. (m\u00e0quina)\"\"\"\nfrom typing import Any\nfrom .calliope import MicroBitDigitalPin\n\ndef unique_id() -> bytes:\n    \"\"\"Obt\u00e9 una cadena de bytes amb un identificador \u00fanic d'una placa.\n\nExample: ``machine.unique_id()``\n\n:return: An identifier that varies from one board instance to another.\"\"\"\n    ...\n\ndef reset() -> None:\n    \"\"\"Reinicia el dispositiu d'una manera semblant a la de pr\u00e9mer el bot\u00f3 extern de REINICI. (reiniciar)\n\nExample: ``machine.reset()``\"\"\"\n    ...\n\ndef freq() -> int:\n    \"\"\"Obt\u00e9 la freq\u00fc\u00e8ncia en Hertz de la CPU\n\nExample: ``machine.freq()``\n\n:return: The CPU frequency.\"\"\"\n    ...\n\ndef disable_irq() -> Any:\n    \"\"\"Desactiva les sol\u00b7licituds d'interrupci\u00f3. (desabilita irq)\n\nExample: ``interrupt_state = machine.disable_irq()``\n\n:return: the previous IRQ state which should be considered an opaque value\n\nThe return value should be passed to the ``enable_irq`` function to restore\ninterrupts to their original state.\"\"\"\n    ...\n\ndef enable_irq(state: Any) -> None:\n    \"\"\"Torna a habilitar les sol\u00b7licituds d'interrupci\u00f3. (habilita irq)\n\nExample: ``machine.enable_irq(interrupt_state)``\n\n:param state: (estat) El valor retornat per la crida m\u00e9s recent a la funci\u00f3 ``disable_irq``.\"\"\"\n    ...\n\ndef time_pulse_us(pin: MicroBitDigitalPin, pulse_level: int, timeout_us: int=1000000) -> int:\n    \"\"\"Cronometra una pulsaci\u00f3 en un pin. (mesura la durada d'una pulsaci\u00f3 en un pin)\n\nExample: ``time_pulse_us(pin0, 1)``\n\nIf the current input value of the pin is different to ``pulse_level``, the\nfunction first waits until the pin input becomes equal to\n``pulse_level``, then times the duration that the pin is equal to\n``pulse_level``. If the pin is already equal to ``pulse_level`` then timing\nstarts straight away.\n\n:param pin: El pin a utilitzar\n:param pulse_level: (nivell de pulsaci\u00f3) 0 per cronometrar la durada de l'estat baix o 1 per cronometrar la durada de l'estat alt\n:param timeout_us: (temps d'espera a la resposta excedit en microsegons) Temps d'espera d'un microsegon\n:return: The duration of the pulse in microseconds, or -1 for a timeout waiting for the level to match ``pulse_level``, or -2 on timeout waiting for the pulse to end\"\"\"\n    ...\n\nclass mem:\n    \"\"\"La classe per a les vistes de la mem\u00f2ria ``mem8``, ``mem16`` i ``mem32``.\"\"\"\n\n    def __getitem__(self, address: int) -> int:\n        \"\"\"Accedeix a un valor de la mem\u00f2ria\n\n:param address: (adre\u00e7a) L'adre\u00e7a de la mem\u00f2ria\n:return: The value at that address as an integer.\"\"\"\n        ...\n\n    def __setitem__(self, address: int, value: int) -> None:\n        \"\"\"Assigna un valor a l'adre\u00e7a donada\n\n:param address: (adre\u00e7a) L'adre\u00e7a de la mem\u00f2ria\n:param value: (valor) El valor enter que cal assignar.\"\"\"\n        ...\nmem8: mem\n\"\"\"vista de la mem\u00f2ria 8-bit (byte)\"\"\"\nmem16: mem\n\"\"\"vista de la mem\u00f2ria 16-bit\"\"\"\nmem32: mem\n\"\"\"vista de la mem\u00f2ria 32-bit\"\"\"",
    "/typeshed/stdlib/math.pyi": "",
    "/typeshed/stdlib/micropython.pyi": "",
    "/typeshed/stdlib/music.pyi": "\"\"\"Crea i toca melodies. (m\u00fasica)\"\"\"\nfrom typing import Optional, Tuple, Union, List\nfrom .calliope import MicroBitDigitalPin, pin0\nDADADADUM: Tuple[str, ...]\n\"\"\"Melodia: l'obertura de la cinquena simfonia de Beethoven en Do menor.\"\"\"\nENTERTAINER: Tuple[str, ...]\n\"\"\"Melodia: el fragment inicial del cl\u00e0ssic  Ragtime de Scott Joplin \"The Entertainer\".\"\"\"\nPRELUDE: Tuple[str, ...]\n\"\"\"Melodia: obertura del primer Preludi en Do Major dels 48 Preludis i Fugues de J.S. Bach. (preludi)\"\"\"\nODE: Tuple[str, ...]\n\"\"\"Melodia: el tema \"Oda a l'alegria\" de la 9a simfonia en Re menor de Beethoven. (oda)\"\"\"\nNYAN: Tuple[str, ...]\n\"\"\"Melodia: el tema Nyan Cat (http://www.nyan.cat/).\n\nThe composer is unknown. This is fair use for educational porpoises (as they say in New York).\"\"\"\nRINGTONE: Tuple[str, ...]\n\"\"\"Melodia: quelcom que sona com un to de trucada de tel\u00e8fon m\u00f2bil. (to de trucada)\n\nTo be used to indicate an incoming message.\n\"\"\"\nFUNK: Tuple[str, ...]\n\"\"\"Melodia: una l\u00ednia de baix funky per a agents secrets i cervells criminals.\"\"\"\nBLUES: Tuple[str, ...]\n\"\"\"Melodia: un  blues walking bass boogie-woogie de dotze compassos.\"\"\"\nBIRTHDAY: Tuple[str, ...]\n\"\"\"Melodia:  \u201cFeli\u00e7 aniversari\u2026\u201d (aniversari)\n\nFor copyright status see: http://www.bbc.co.uk/news/world-us-canada-34332853\n\"\"\"\nWEDDING: Tuple[str, ...]\n\"\"\"Melodia: el cor nupcial de l'\u00f2pera Lohengrin de Wagner. (casament)\"\"\"\nFUNERAL: Tuple[str, ...]\n\"\"\"Melodia: la \u201cmarxa f\u00fanebre\u201d com es coneix  la Sonata per a piano No 2. en Si bemoll menor Op. 35 de Fr\u00e9d\u00e9ric Chopin .\"\"\"\nPUNCHLINE: Tuple[str, ...]\n\"\"\"Melodia: un fragment divertit que significa que s'ha fet una broma.\"\"\"\nPYTHON: Tuple[str, ...]\n\"\"\"Melodia: la marxa de John Philip Sousa \"Liberty Bell\", tamb\u00e9 conegut com, el tema de \"Monty Python's Flying Circus\" (a partir de la qual s'anomena el llenguatge de programaci\u00f3 Python).\"\"\"\nBADDY: Tuple[str, ...]\n\"\"\"Melodia: entrada d'un dolent a l'era del cinema mut. (dolent)\"\"\"\nCHASE: Tuple[str, ...]\n\"\"\"Melodia: escena de persecuci\u00f3 de l'era del cinema mut. (persecuci\u00f3)\"\"\"\nBA_DING: Tuple[str, ...]\n\"\"\"Melodia: senyal breu per indicar que alguna cosa ha passat.\"\"\"\nWAWAWAWAA: Tuple[str, ...]\n\"\"\"Melodia: un tromb\u00f3 molt trist.\"\"\"\nJUMP_UP: Tuple[str, ...]\n\"\"\"Melodia: per utilitzar-se en un joc, indicant moviment cap amunt. (saltar cap amunt)\"\"\"\nJUMP_DOWN: Tuple[str, ...]\n\"\"\"Melodia: per utilitzar en un joc, que indica moviment cap avall. (saltar cap avall)\"\"\"\nPOWER_UP: Tuple[str, ...]\n\"\"\"Melodia: una fanf\u00e0rria per indicar un assoliment desbloquejat. (engegar)\"\"\"\nPOWER_DOWN: Tuple[str, ...]\n\"\"\"Melodia: una trista fanf\u00e0rria per indicar un assoliment perdut. (apagar)\"\"\"\n\ndef set_tempo(ticks: int=4, bpm: int=120) -> None:\n    \"\"\"Estableix el tempo aproximat per la reproducci\u00f3.\n\nExample: ``music.set_tempo(bpm=120)``\n\n:param ticks: El nombre de tics que constitueixen un ritme.\n:param bpm: Un nombre enter determinant quantes pulsacions per minut.\n\nSuggested default values allow the following useful behaviour:\n\n- music.set_tempo() \u2013 reset the tempo to default of ticks = 4, bpm = 120\n- music.set_tempo(ticks=8) \u2013 change the \u201cdefinition\u201d of a beat\n- music.set_tempo(bpm=180) \u2013 just change the tempo\n\nTo work out the length of a tick in milliseconds is very simple arithmetic:\n60000/bpm/ticks_per_beat. For the default values that\u2019s\n60000/120/4 = 125 milliseconds or 1 beat = 500 milliseconds.\"\"\"\n    ...\n\ndef get_tempo() -> Tuple[int, int]:\n    \"\"\"Obt\u00e9 el tempo actual com una tupla d'enters:``(ticks, bpm)``. (obt\u00e9 el tempo)\n\nExample: ``ticks, beats = music.get_tempo()``\n\n:return: The temp as a tuple with two integer values, the ticks then the beats per minute.\"\"\"\n    ...\n\ndef play(music: Union[str, List[str], Tuple[str, ...]], pin: Optional[MicroBitDigitalPin]=pin0, wait: bool=True, loop: bool=False) -> None:\n    \"\"\"Tocar m\u00fasica\n\nExample: ``music.play(music.NYAN)``\n\n:param music: (m\u00fasica) m\u00fasica especificada en `una notaci\u00f3 especial <https://microbit-micropython.readthedocs.io/en/v2-docs/music.html#musical-notation>`_\n:param pin: el pin de sortida per utilitzar-lo amb un altaveu extern (``pin0`` per defecte), ``None`` per no fer so.\n:param wait: (espera) Si ``wait`` s'estableix en ``True``, aquesta funci\u00f3 est\u00e0 bloquejant.\n:param loop: (bucle) Si el ``loop`` s'estableix en ``True``, la melodia es repeteix fins que es crida ``stop`` o s'interromp la trucada de bloqueig.\n\nMany built-in melodies are defined in this module.\"\"\"\n    ...\n\ndef pitch(frequency: int, duration: int=-1, pin: Optional[MicroBitDigitalPin]=pin0, wait: bool=True) -> None:\n    \"\"\"Toca una nota. (altura del to)\n\nExample: ``music.pitch(185, 1000)``\n\n:param frequency: (freq\u00fc\u00e8ncia) Una freq\u00fc\u00e8ncia de nombre enter\n:param duration: (Durada - duraci\u00f3) Una duraci\u00f3 d'un mil\u00b7lisegon. Si \u00e9s negativa, el so \u00e9s continu fins a la nova crida o una crida a  ``stop``.\n:param pin: Pin de sortida opcional (``pin0`` per defecte).\n:param wait: (espera) Si ``wait`` s'estableix en ``True``, aquesta funci\u00f3 est\u00e0 bloquejant.\n\nFor example, if the frequency is set to 440 and the length to\n1000 then we hear a standard concert A for one second.\n\nYou can only play one pitch on one pin at any one time.\"\"\"\n    ...\n\ndef stop(pin: Optional[MicroBitDigitalPin]=pin0) -> None:\n    \"\"\"Atura tota la reproducci\u00f3 de m\u00fasica a l'altaveu integrat i qualsevol so de sortida de pin. (atura)\n\nExample: ``music.stop()``\n\n:param pin: Es pot proporcionar un argument opcional per especificar un pin, per exemple ``music.stop(pin1)``.\"\"\"\n\ndef reset() -> None:\n    \"\"\"Restableix els tics, ppm, duraci\u00f3 i octava al seu valor per defecte. (reiniciar)\n\nExample: ``music.reset()``\n\nValues:\n- ``ticks = 4``\n- ``bpm = 120``\n- ``duration = 4``\n- ``octave = 4``\"\"\"\n    ...",
    "/typeshed/stdlib/neopixel.pyi": "\"\"\"Cintes LED RGB i RGBW adre\u00e7ables individualment.\"\"\"\nfrom .calliope import MicroBitDigitalPin\nfrom typing import Tuple\n\nclass NeoPixel:\n\n    def __init__(self, pin: MicroBitDigitalPin, n: int, bpp: int=3) -> None:\n        \"\"\"Inicialitza una nova tira de LED de neopixel controlada mitjan\u00e7ant un pin.\n\nExample: ``np = neopixel.NeoPixel(pin0, 8)``\n\nTo support RGBW neopixels, a third argument can be passed to\n``NeoPixel`` to indicate the number of bytes per pixel (``bpp``).\nFor RGBW, this is is 4 rather than the default of 3 for RGB and GRB.\n\nEach pixel is addressed by a position (starting from 0). Neopixels are\ngiven RGB (red, green, blue) / RGBW (red, green, blue, white) values\nbetween 0-255 as a tuple. For example, in RGB, ``(255,255,255)`` is\nwhite. In RGBW, ``(255,255,255,0)`` or ``(0,0,0,255)`` is white.\n\nSee `the online docs <https://microbit-micropython.readthedocs.io/en/v2-docs/neopixel.html>`_ for warnings and other advice.\n\n:param pin: El pin que controla la tira de neop\u00edxels.\n:param n: El nombre de neop\u00edxels de la tira.\n:param bpp: Bytes per p\u00edxel. Per al suport de micro:bit V2 RGBW neopixel, passa 4 en lloc de 3 per defecte per a RGB i GRB.\"\"\"\n        ...\n\n    def clear(self) -> None:\n        \"\"\"Esborra tots els p\u00edxels.\n\nExample: ``np.clear()``\"\"\"\n        ...\n\n    def show(self) -> None:\n        \"\"\"mostra els p\u00edxels.\n\nExample: ``np.show()``\n\nMust be called for any updates to become visible.\"\"\"\n        ...\n\n    def write(self) -> None:\n        \"\"\"Mostra els p\u00edxels (nom\u00e9s micro:bit V2) (escriu)\n\nExample: ``np.write()``\n\nMust be called for any updates to become visible.\n\nEquivalent to ``show``.\"\"\"\n        ...\n\n    def fill(self, colour: Tuple[int, ...]) -> None:\n        \"\"\"Acoloreix tots els p\u00edxels amb un valor RGB/RGBW determinat. (omple)\n\nExample: ``np.fill((0, 0, 255))``\n\n:param colour: (color) Una tupla de la mateixa longitud que el nombre de bytes per p\u00edxel (bpp).\n\nUse in conjunction with ``show()`` to update the neopixels.\"\"\"\n        ...\n\n    def __setitem__(self, key: int, value: Tuple[int, ...]) -> None:\n        \"\"\"Estableix un color de p\u00edxel.\n\nExample: ``np[0] = (255, 0, 0)``\n\n:param key: El nombre de p\u00edxels.\n:param value: (valor) El color.\"\"\"\n\n    def __getitem__(self, key: int) -> Tuple[int, ...]:\n        \"\"\"Obt\u00e9 un color de p\u00edxel.\n\nExample: ``r, g, b = np[0]``\n\n:param key: El nombre de p\u00edxels.\n:return: The colour tuple.\"\"\"\n\n    def __len__(self) -> int:\n        \"\"\"Obt\u00e9 la longitud d'aquesta cinta de p\u00edxels.\n\nExample: ``len(np)``\"\"\"",
    "/typeshed/stdlib/os.pyi": "",
    "/typeshed/stdlib/power.pyi": "\"\"\"Manage the power modes of the micro:bit (V2 only).\n\"\"\"\n\nfrom microbit import MicroBitDigitalPin, Button\nfrom typing import Optional, Tuple, Union\n\ndef off() -> None:\n    \"\"\"Power down the board to the lowest possible power mode.\n\n    Example: ``power.off()``\n\n    This is the equivalent to pressing the reset button for a few seconds,\n    to set the board in \"Off mode\".\n\n    The micro:bit will only wake up if the reset button is pressed or,\n    if on battery power, when a USB cable is connected.\n\n    When the board wakes up it will start for a reset state, so your program\n    will start running from the beginning.\n    \"\"\"\n    ...\n\ndef deep_sleep(\n    ms: Optional[int] = None,\n    wake_on: Optional[\n        Union[MicroBitDigitalPin, Button] | Tuple[MicroBitDigitalPin | Button, ...]\n    ] = None,\n    run_every: bool = True,\n) -> None:\n    \"\"\"Set the micro:bit into a low power mode where it can wake up and continue operation.\n\n    Example: ``power.deep_sleep(wake_on=(button_a, button_b))``\n\n    The program state is preserved and when it wakes up it will resume\n    operation where it left off.\n\n    Deep Sleep mode will consume more battery power than Off mode.\n\n    The wake up sources are configured via arguments.\n\n    The board will always wake up when receiving UART data, when the reset\n    button is pressed (which resets the board) or, in battery power,\n    when the USB cable is inserted.\n\n    When the ``run_every`` parameter is set to ``True`` (the default), any\n    function scheduled with ``run_every`` will momentarily wake up the board\n    to run and when it finishes it will go back to sleep.\n\n    :param ms: A time in milliseconds to wait before it wakes up.\n    :param wake_on: A single instance or a tuple of pins and/or buttons to wake up the board, e.g. ``deep_sleep(wake_on=button_a)`` or ``deep_sleep(wake_on=(pin0, pin2, button_b))``.\n    :param run_every: A boolean to configure if the functions scheduled with ``microbit.run_every`` will continue to run while it sleeps.\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/radio.pyi": "",
    "/typeshed/stdlib/random.pyi": "",
    "/typeshed/stdlib/speech.pyi": "\"\"\"Fes que la micro:bit parli, canti i fer altres expressions com els sons.\"\"\"\nfrom typing import Optional\nfrom .calliope import MicroBitDigitalPin, pin0\n\ndef translate(words: str) -> str:\n    \"\"\"Tradueix paraules angleses a fonemes. (tradueix)\n\nExample: ``speech.translate('hello world')``\n\n:param words: (paraules) Una cadena de paraules angleses.\n:return: A string containing a best guess at the appropriate phonemes to pronounce.\nThe output is generated from this `text to phoneme translation table <https://github.com/s-macke/SAM/wiki/Text-to-phoneme-translation-table>`_.\n\nThis function should be used to generate a first approximation of phonemes\nthat can be further hand-edited to improve accuracy, inflection and\nemphasis.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef pronounce(phonemes: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: Optional[MicroBitDigitalPin]=pin0) -> None:\n    \"\"\"Pronuncia fonemes. (pronuncia)\n\nExample: ``speech.pronounce(' /HEHLOW WERLD')``\n\n:param phonemes: (fonemes) La cadena de fonemes a pronunciar\n:param pitch: (to) Un nombre que representa la freq\u00fc\u00e8ncia de la veu\n:param speed: (velocitat) Un nombre que representa la velocitat de la veu\n:param mouth: (boca) Un nombre que representa la boca de la veu\n:param throat: Un nombre que representa la gola de la veu\n:param pin: L'argument opcional per especificar el pin de sortida es pot utilitzar per anul\u00b7lar el valor predeterminat de ``pin0``.\nSi no vols que es reprodueixi cap so en els pins, podts utilitzar ``pin=None``. Nom\u00e9s micro:bit V2.\n\nOverride the optional pitch, speed, mouth and throat settings to change the\ntimbre (quality) of the voice.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef say(words: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: MicroBitDigitalPin=pin0) -> None:\n    \"\"\"Digues paraules en angl\u00e8s.\n\nExample: ``speech.say('hello world')``\n\n:param words: (paraules) La cadena de paraules a dir.\n:param pitch: (to) Un nombre que representa la freq\u00fc\u00e8ncia de la veu\n:param speed: (velocitat) Un nombre que representa la velocitat de la veu\n:param mouth: (boca) Un nombre que representa la boca de la veu\n:param throat: Un nombre que representa la gola de la veu\n:param pin: L'argument opcional per especificar el pin de sortida es pot utilitzar per anul\u00b7lar el valor predeterminat del ``pin0``.\nSi no vols que es reprodueixi cap so en els pins, pots utilitzar ``pin=None``. Nom\u00e9s micro:bit V2.\n\nThe result is semi-accurate for English. Override the optional pitch, speed,\nmouth and throat settings to change the timbre (quality) of the voice.\n\nThis is a short-hand equivalent of:\n``speech.pronounce(speech.translate(words))``\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef sing(phonemes: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: MicroBitDigitalPin=pin0) -> None:\n    \"\"\"Cantar fonemes.\n\nExample: ``speech.sing(' /HEHLOW WERLD')``\n\n:param phonemes: (fonemes) La cadena de paraules a cantar.\n:param pitch: (to) Un nombre que representa la freq\u00fc\u00e8ncia de la veu\n:param speed: (velocitat) Un nombre que representa la velocitat de la veu\n:param mouth: (boca) Un nombre que representa la boca de la veu\n:param throat: Un nombre que representa la gola de la veu\n:param pin: L'argument opcional per especificar el pin de sortida es pot utilitzar per anul\u00b7lar el valor predeterminat de ``pin0``.\nSi no vols que es reprodueixi cap so en els pins, podts utilitzar ``pin=None``. Nom\u00e9s micro:bit V2.\n\nOverride the optional pitch, speed, mouth and throat settings to change\nthe timbre (quality) of the voice.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...",
    "/typeshed/stdlib/struct.pyi": "",
    "/typeshed/stdlib/sys.pyi": "",
    "/typeshed/stdlib/this.pyi": "",
    "/typeshed/stdlib/time.pyi": "",
    "/typeshed/stdlib/types.pyi": "",
    "/typeshed/stdlib/typing.pyi": "",
    "/typeshed/stdlib/typing_extensions.pyi": "",
    "/typeshed/stdlib/uarray.pyi": "",
    "/typeshed/stdlib/ucollections.pyi": "",
    "/typeshed/stdlib/uerrno.pyi": "",
    "/typeshed/stdlib/urandom.pyi": "",
    "/typeshed/stdlib/ustruct.pyi": "",
    "/typeshed/stdlib/usys.pyi": "",
    "/typeshed/stdlib/utime.pyi": "",
    "/typeshed/stdlib/calliopemini/__init__.pyi": "",
    "/typeshed/stdlib/calliopemini/accelerometer.pyi": "",
    "/typeshed/stdlib/calliopemini/audio.pyi": "",
    "/typeshed/stdlib/calliopemini/compass.pyi": "",
    "/typeshed/stdlib/calliopemini/display.pyi": "",
    "/typeshed/stdlib/calliopemini/i2c.pyi": "",
    "/typeshed/stdlib/calliopemini/microphone.pyi": "",
    "/typeshed/stdlib/calliopemini/speaker.pyi": "",
    "/typeshed/stdlib/calliopemini/spi.pyi": "",
    "/typeshed/stdlib/calliopemini/uart.pyi": "",
    "/typeshed/stdlib/_typeshed/__init__.pyi": "",
    "/typeshed/stdlib/collections/__init__.pyi": "",
    "/src/pyrightconfig.json": "{ \n  \"pythonVersion\": \"3.6\",\n  \"pythonPlatform\": \"Linux\",\n  \"typeCheckingMode\": \"basic\",\n  \"typeshedPath\": \"/typeshed/\",\n  \"reportMissingModuleSource\": false,\n  \"reportWildcardImportFromLibrary\": false,\n  \"verboseOutput\": true\n }\n"
  }
}